# ch3. 함수

함수를 잘 만드는법

읽기 쉽고 이해하기 쉬운 함수, 의도를 분명히 표현하는 함수 구현 방법과 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있는지를 알려주는 내용이다. 

## 1. 작게 만들어라!

함수는 작을수록 즉 짧을수록 좋다. 

if문/else문/while문 등에 들어가는 블록은 한 줄이어야 하고 대개 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.

즉 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

## 2. 한 가지만(처리) 해라!

한가지? 함수 이름 아래에서 [추상화](https://onestone-dev.tistory.com/m/3) 수준이 하나인 단계만 수행한다. 하나의 작업

함수를 만드는 이유? 큰 개념(함수이름)을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위함이다. 

함수가 한가지만 하는지 판단하는 방법: 추상화 수준 단계가 하나인지, 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는것이다.

## 3.  함수 당 추상화 수준은 하나로!

함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 

추상화 수준
높음: getHtml()
중간: String pagePathName = PathParser.render(pagepath);
낮음: .append("\n")

특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어렵기 때문에 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 근본 개념과 세부사항을 뒤섞기 시작하면, 사람들이 함수에 세부사항을 점점 더 추가한다. 

코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.이를 내려가기 규칙이라 부른다. 

추상화 수준이 하나인 함수 즉 핵심은 짧으면서도 한가지만 하는 함수를 읽어내려 가듯이 구현하면 추상화 수준을 일관되게 유지하기 쉬워진다. 

이 원칙을 사용하면 각 함수는 다음 함수를 소개하고 일정한 추상화 수준을 유지한다. 

## 4. switch문

switch문은 작게 만들기 어렵다. case 분기가 단 두 개인 switch문도 길며, 단일 블록이나 함수를 선호한다.

또 본질적으로 n가지를 처리하기 때문에 한 가지 작업만 하게 만들기도 어렵다.

하지만 다형성을 이용해 switch문을 저차원 클래스에 숨기고 반복하지 않는 방법이 있다.

```c
// 직원 유형에 따라 다른 값을 계산해 반환하는 함수
public Money calculatePay(Employee e)
throws InvalidEmployeeType {
	switch (e.type) {
		case COMMISSIONED:
			return calculateCommissionedPay(e);
		case HOURLY:
			return calculateHourlyPay(e);
		case SALSRIED:
			return calculateSalariedPay(e);
		default:
			throw new InvalidEmployeeType(e.type);
	}
}
```

[위 함수의 문제]

1. 함수가 길다. 새 직원의 유형 추가시 더 길어짐.
2. 한 가지 작업만 수행하지 않음. 
3. SRP. Single Responsibility Principle를 위반. 코드를 변경할 이유가 여럿이기 때문.
4. OCP. Open Closed Principle를 위반. 새 직원 유형을 추가할 때마다 코드를 변경해
5. 가장 심각한 문제는 위 함수와 동일한 구조의 함수가 무한정 존재

ex) is Payday(Employee e, Date date);

deliverPay(Employee e, Money pay);

## 5. 서술적인 이름을 사용하라!

짧고 어려운 이름보다 길어도 함수가 하는 일을 좀 더 잘 표현하는 서술적인 이름이 좋다. 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한 다음 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다. 이런 저런 이름을 넣어 코드를 읽어보면 더 좋다. 최신 IDE에서 이름 바꾸기는 쉬워 이를 사용해 이런저런 이름을 시도한 후 최대한 서술적인 이름을 골라도 좋다. 

서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구,명사,동사를 사용한다.

ex) includeSetupAndTeardownPages, includeSetupPages, includeTeardownPage, includeSetupPage

문체가 비슷하면 이야기를 순차적으로 풀어가기도 쉬워진다.

## 6. 함수 인수

```java
int add(int x, int y){   //x,y 가 매개변수
	return x + y;
}

add(2,7); //2,7이 인수
```

매개변수란 함수를 정의할 때 사용되는 변수다. 인수는 함수가 호출될 때 매개변수에 실제로 담기는 값이다.

함수에서 이상적인 인수 개수는 0개(무항)이고 그 다음이 1개(단항), 2개(이항)고 3개(삼항)는 가능한 피하는게 좋고 4개이상(다항)은 특별한 이유가 있어도 사용하면 안 된다. 

인수가 많아질수록 인수 조합으로 함수를 검증하는 테스트 케이스를 작성하기에 더 어렵다. 

흔히 함수에다 인수로 입력을 넘기고 반환값으로 출력을 받는다는 개념에 익숙해서 함수에서 인수로 결과를 받으리라 기대하지 않는다. 

최선은 입력 인수가 없는 경우이며  차선은 입력 인수가 1개 뿐인 경우이다. 

### 단항형식

함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는

1. 인수에 질문을 던지거나 ex) boolean fileExists(”MyFile”)

2.인수를 뭔가로 변환해 결과를 반환하는 경우다.  

ex) InputStream fileOpen(”MyFile”) :String형의 파일 이름을 InputStream으로 변환

함수 이름을 지을 때는 위 두 경우를 분명히 구분하고 일관적인 방식으로 사용한다.

이벤트 함수는 드물게 사용하지만 유용한 단항 함수 형식으로 입력인수만 있고 출력인수는 없다. 프로그램은 함수 호출을 이벤트로 해석해 입력 인수로 시스템 상태를 바꾼다.

 ex) passwordAttemptFailedNtimes(int attempts) 

이벤트라는 사실이 코드에 명확히 드러나야 하므로 이름과 문맥을 주의해서 선택한다. 

위 경우가 아니면 단항함수는 가급적 피한다. 

### 플래그 인수

플래그 인수는 함수로 부울 값(boolean)을 넘기는데 이는 함수가 한꺼번에 여러 가지를 처리한다 즉 플래그가 참이면 이걸하고 거짓이면 저걸 한다는 말임으로 이는 안좋음. 

****flag는 1bit로 참 (=1) 또는 거짓(=0)의 값을 가지며, 이름의 의미대로 깃발(flag)이 올라가거나 내려간 것으로 표현하기도 한다. 이 flag들을 모아놓은 레지스터를 flag register라 하며, flag register는(ALU를 사용하는) 연산의 결과로만 변경된다.****

### 이항함수

인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 

ex) writeField(name)는 writeField(outputStream, name)보다 이해하기 쉽다. 

직교 좌표계 점 Point p = new Point(0,0)은 일반적으로 한 값을 표현하는 인수 2개를 가지고 자연적인 순서도 있으므로 이항 함수가 적절하다. outputStream, name은 한 값을 표현하지도, 자연적인 순서가 있지도 않다. 이항함수 assertEquals(expected, acrtual)도 두 인수에 자연적인 순서가 없고 expect 다음에 actual이 온다는 순서를 인위적으로 기억해야한다.  

### 삼항 함수

인수가 3개인 함수는 이해가 더 어렵. 

assertEquals(message, expected, actual)이라는 함수는 message를 무시하고 expected가 첫 인수임. assertEquals(1.0, amount, .001)은 삼항함수로 부동소수점 비교가 상대적이다. 

### 인수 객체

인수가 2-3개 필요하면 일부를 독자적인 클래스 변수로 선언할 가능성이 있다. 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국 개념을 표현함. 

### 인수 목록

인수 개수가 가변적인 함수도 필요함. 

ex) String.format(”%s worked %.2f” hours.”, name, hours); 

위 코드처럼 가변 인수 전부를 동등하게 취급하면 list형 인수 하나로 취급할 수 있음.

가변인수를 취하는 모든 함수(단항, 이항, 삼항)에도 같은 원리가 적용되지만 이를 넘어서는 인수를 사용하면 문제가 있다. 

### 동사와 키워드

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수. 

단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야함.ex) write(name)

ex) 함수 이름에 키워드 추가(인수 이름 넣음)하면 인수 순서를 기억할 필요가 없어짐. 

assertEquals → assertExpectedEqualsActual(expected, actual) 

## 7.부수 효과를 일으키지 마라!

부수 효과 = 거짓말 ( 함수에서 한 가지를 하겠다고 했지만 다른짓도 함. )

시간적인 결함 temporal coupling, 순서 종속성 order dependency을 초래.

Ex) checkPassword함수가 userName과 password를 확인하는데 이 함수의 부수 효과로 Session.initialize()호출을 해  세션을 초기화 한다고 하자. 함수 호출시 함수 이름만 보면 부수 효과는 드러나지 않기 때문에 암호만 확인하는줄 알고 기존 세션 정보를 지워버릴 위험이 있다. (시간적인 결함)

그래서 시간적인 결함이 필요하면 함수 이름을 분명하게 명시해야함. 

checkPassword→checkPasswordAndInitializeSession (함수가 한 가지만 한다는 규칙을 위반하긴함.)

### 출력 인수

일반적으로 인수를 함수 입력으로 해석. 

appendFooter(s); 라는 함수는 

public void appendFooter(StringBuffer report) 즉 함수 선언부를 찾아봐야 인수 s가 출력 인수라는걸 알 수 있다.  이렇게 함수 선언부를 찾아보는건 코드를 보다 주춤하는것과 같아 피해야한다. 

객체 지향 언어에서는 출력 인수를 사용할 필요가 거의 없다. 일반적으로 피해야한다. 

appendFooter(s); → report.appendFooter();

함수에서 상태 변경시에는 함수가 속한 객체 상태를 변경하는 방식을 택함.

## 8. 명령과 조회를 분리하라!

함수는 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나만 해야한다.

Ex) public boolean set(String attribute,, String value);

위 함수는 이름이 attribute인 속성을 찾아 값을 value로 설정한 후 성공하면 true, 실패하면 false를 반환함.

if (set(”username”, “unclebob”)) …이와 같은 코드가 나오는데 이는 “username”이 “unclebob”으로 설정되어 있는지 확인하는 코드인가? “username”이 “unclebob”으로 설정하는 코드인가? 헷갈림.

그래서 명령과 조회를 분리해 혼란스럽지 않게 함.

if (attributeExists(”username”)) {

setAttribute(”username”, “unclebob”);

…

}

## 9.오류 코드보다 예외를 사용하라!

명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반함. if 문에서 명령을 표현식으로 사용하기 쉬워서. 

오류코드 대신 예외(try/catch)를 사용하며 오류처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해짐. 

### Try/Catch 블록 뽑아내기

Try/Catch 블록은 코드 구조에 혼란을 일으키며 정상 동작과 오류 처리 동작을 뒤섞기 때문에 별도 함수로 뽑아내는 편이 좋음. 코드를 이해하고 수정하기 쉬워짐. 

### 오류 처리도 한 가지 작업이다.

함수가 한 가지 작업만 해야함. 오류처리도 한가지 작업에 속해 오류를 처리하는 함수는 오류만 처리해야 마땅함.

### Error.java의존성 자석

오류코드 반환 = 어디선가 오류코드를 정의한다는 뜻.

프로그래머는 재컴파일/재배치가 번거로워 새 오류 코드를 정의하고 싶지 않아 새 오류 코드를 추가하는 대신 기존 오류코드를 재 사용함. 

오류코드 대신 예외 사용시 새 예외는 Exception클래스에서 파생됨으로 재컴파일/재배치 없이 새 예외 클래스에 추가 가능.

## 10.반복하지 마라!

중복이 되면 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 다 손봐야하고 어느 한곳 이라도 빠뜨리는 바람에 오류가 날 확률도 높다. 중복을 없애면 모듈 가독성이 높아짐. 중복은 소프트웨어에서의 모든 악의 근원이다. 중복을 없애거나 제어할 목적으로 많은 원칙과 기법이 나옴. 

## 11.구조적 프로그래밍

에츠허르 데이크스트라의 구조적 프로그래밍 원칙

: 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야함. 즉 함수는 return문이 하나이고 루프 안에서 break, continue, goto는 사용불가.

 이 원칙은 함수가 클 때만 상당한 이익을 제공하고 작을때는 별 이익 없음. 

그래서 함수를 작게 만들면 return, break, continue를 여러번 사용해도됨. goto문은 큰 함수에서만 의미가 있어 작은 함수에서는 피해야함. 

## 12.함수를 어떻게 짜죠?

글짓기가 먼저 생각을 기록한 후 읽기 좋게 다듬듯이 함수를 짤 때도 처음 짠 서투른 코드를 테스트 하는 단위 테스트 케이스를 통과 시키며 코드를 다듬는다.

## 13.결론

master 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다.

함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아 떨어져야 이야기를 풀어가기가 쉬워진다.
